<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="websockets">
  <title>WebSockets &amp; STOMP</title>

  <section>
    <title>Overview</title>

    <para>TorqueBox provides real-time bidirectional communication between
    applications and web-browsers using a combination of WebSockets and STOMP.
    Raw access to WebSockets is not provided. Instead, multiplexed
    communication is supported through the layering of messaging semantics on
    top. Additionally, optional integration into other messaging systems (such
    as JMS/HornetQ) are provided to enable advanced application
    architectures.</para>

    <para>TorqueBox provides support for Stomplets to allow explicit control
    and design of messaging end-points, instead of simple direct bridging to
    some other underlying messaging technology, such as a JMS broker.</para>

    <section id="websockets-overview">
      <title>What are WebSockets?</title>

      <para>WebSockets is a new specification to allow synchronous
      bidirectional communication between a client (such as a web browser) and
      a server. While simliar to TCP sockets, WebSockets is a protocol that
      operates as an upgraded HTTP connection, exchanging variable-length
      <emphasis>frames</emphasis> between the two parties, instead of a
      stream.</para>

      <para>A browser may access a WebSockets-based service using Javascript.
      Once connected, the client and server must determine the meaning of any
      data sent across the socket. The WebSockets transport itself provides no
      protocol semantics beyond data frames passing each direction.</para>
    </section>

    <section>
      <title>What is STOMP?</title>

      <para>STOMP stands for Stream-Oriented Messaging Protocol. STOMP defines
      a protocol for clients and servers to communicate with messaging
      semantics. STOMP does not define any implementation details, but rather
      addresses an easy-to-implement wire protocol for messaging
      integrations.</para>

      <para>STOMP provides higher semantics on top of the WebSockets
      transport. STOMP defines a handful of frame types that are mapped to
      WebSockets frames.</para>

      <para><itemizedlist>
          <listitem>
            <para>CONNECT</para>
          </listitem>

          <listitem>
            <para>SUBSCRIBE</para>
          </listitem>

          <listitem>
            <para>UNSUBSCRIBE</para>
          </listitem>

          <listitem>
            <para>SEND (messages sent to the server)</para>
          </listitem>

          <listitem>
            <para>MESSAGE (for messages send from the server)</para>
          </listitem>

          <listitem>
            <para>BEGIN, COMMIT, ROLLBACK</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>What are Stomplets?</title>

      <para>The Stomplet specification defines a controller (in the MVC sense
      of controllers) API for working with asynchronous messaging end-points.
      Stomplets are mapped to STOMP destinations (possibly using wildcards,
      like Rails routes), coordinating clients subscribing to receive messages
      and clients sending messages.</para>

      <para>Stomplets are long-lived stateful controllers.</para>
    </section>
  </section>

  <section>
    <title>Ruby Stomplets</title>

    <para>Ruby Stomplets have a handful of methods which must be implemented
    to support all messaging actions.</para>

    <para><itemizedlist>
        <listitem>
          <para><code>configure(config)</code> Configures the Stomplet with
          its name/value configuration and context.</para>
        </listitem>

        <listitem>
          <para><code>destroy()</code> Destroys the Stomplet and releases
          resources when it is taken out of service.</para>
        </listitem>

        <listitem>
          <para><code>on_subscribe(subscriber)</code> Called when a client
          wishes to receive messages.</para>
        </listitem>

        <listitem>
          <para><code>on_unsubscribe(subscriber)</code> Called when a client
          no longer wishes to receive messages.</para>
        </listitem>

        <listitem>
          <para><code>on_message(message)</code> Called when a client has sent
          a message.</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title><code>configure(config)</code></title>

      <para>The configure(config) method is called for each instance of the
      Stomplet instantiated by the container. The config parameter includes
      any name/value pairs specified in the configuration of the Stomplet for
      a given route.</para>

      <para>The configure(...) method is typically where a Stomplet would
      acquire any resources it needs to handle subscription requests and sent
      messages.</para>
    </section>

    <section>
      <title><code>destroy()</code></title>

      <para>The <code>destroy()</code> method is called for each instance of
      the Stomplet when the container undeploys its route. This method is
      typically where all resources are released and connections to underlying
      systems are terminated.</para>
    </section>

    <section>
      <title><code>on_subscribe(subscriber)</code> and
      <code>on_unsubscribe(subscriber)</code></title>

      <para>The <code>on_subscribe(subscriber)</code> method is called when a
      client wishes to receive messages from a destination matching the
      Stomplet. The same instance of the subcriber parameter is passed to
      <code>on_unsubscribe(...)</code> when the client wishes to cease
      receiving messages and cancel that subscription.</para>

      <para>The subscribe object supports a few useful methods:</para>

      <para><itemizedlist>
          <listitem>
            <para><code>destination</code> String describing the desired
            destination to receive messages from.</para>
          </listitem>

          <listitem>
            <para><code>send(message)</code> Deliver a message to the client
            through this subscription.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title><code>on_message(message)</code></title>

      <para>The on_message(message) method is called with a Stomp message as
      the parameter whenever a client sends a message to a destination handled
      by the Stomplet. The client does not necessarily need to have previous
      subscribed to the destination in order to send messages to it.</para>
    </section>
  </section>

  <section>
    <title>JMS Integration</title>

    <para>TorqueBox provides useful classes to build your own application's
    Stomplets upon. The most useful of these is
    <classname>TorqueBox::Stomp::JmsStomplet</classname>, which handles a
    large portion of bridging between STOMP and JMS, while allowing the
    flexibility to adapt the integration to match your particular
    needs.</para>

    <para>The primary assistance it provides is through two methods:</para>

    <para><itemizedlist>
        <listitem>
          <para>subscribe_to( subscriber, jms_destination_name,
          jms_destination_type )</para>
        </listitem>

        <listitem>
          <para>send_to( stomp_message, jms_destination_name,
          jms_destination_type )</para>
        </listitem>
      </itemizedlist>Your own Stomplet may use these methods to handle the
    heavy-lifting after translating between STOMP destinations and JMS
    destinations.</para>

    <para><example>
        <title>Example JMS Stomplet Bridge</title>

        <para><screen>require 'torquebox-stomp'

class BridgeStomplet &lt; TorqueBox::Stomp::JmsStomplet

  def initialize()
    super
  end

  def configure(stomplet_config)
    super
   
    @destination_type = stomplet_config['type']
    @destination_name = stomplet_config['destination']
  end

  def on_message(stomp_message)
    send_to( stomp_message, @destination_name, @destination_type )
  end

  def on_subscribe(subscriber)
    subscribe_to( subscriber, @destination_name, @destination_type )
  end

end</screen></para>
      </example></para>

    <section>
      <title>Destination and Message compatibility</title>

      <para>When using the <classname>JmsStomplet</classname> to bridge STOMP
      destinations to JMS destination, normal message-encoding occurs. This
      allows your application to send a message to a JMS destination using
      <classname>TorqueBox::Messaging</classname> interfaces as normal. The
      <classname>JmsStomplet</classname> will appropriately decode the
      messages received from the JMS destination. Likewise, any messages sent
      by the <classname>JmsStomplet</classname> will be appropriate encoded in
      order to be consumable by other non-STOMP
      <classname>MessageProcessors</classname>.</para>
    </section>
  </section>

  <section>
    <title>Deployment descriptors</title>

    <para>To deploy Stomplets with your application, a stomp: section is added
    to your application's torquebox.yml descriptor. The section should contain
    named sections for each Stomplet your application needs to deploy. Each
    Stomplet is bound to a route, which works similar to Rails request
    routing, but matches against STOMP destinations instead of web URLs.
    Additionally, it specifies the class of the implementation, along with
    optional configuration in the form of name/value pairs of strings.</para>

    <para>STOMP supports the notion of virtuals, just as with web container.
    By default, if your application specifies a virtual host for the web
    portion of the configuration, the same value will be used for the STOMP
    container. The host may be overridden, though, by specifying a
    <parameter>host:</parameter> parameter within the
    <parameter>stomp:</parameter> block.</para>

    <para><informalexample>
        <para><screen>stomp:
  host: somehost.com
  stomplets:
    stomplet.one:
      route: '/queues/:queue_name'
      class: StompletOne
    foo.stomplet:
      route: '/bridge/foo'
      class: BridgeStomplet
      config:
        type: queue
        destination: /jms-queues/foo
    bar.stomplet:
      route: '/bridge/bar'
      class: BridgeStomplet
      config:
        type: topic
        destination: /jms-topics/bar</screen></para>
      </informalexample></para>
  </section>

  <section>
    <title>Javascript Client</title>

    <para>TorqueBox makes use of the Stilts framework and to implement the
    WebSockets and STOMP stack. TorqueBox includes the Javascript client
    provided by the Stilts distribution.</para>

    <para>Place example here!</para>
  </section>

  <section>
    <title>Other Clients (without WebSockets)</title>

    <para>The Stilts distribution also includes JRuby-based clients and Java
    clients appropriate for communicating with the TorqueBox STOMP service.
    While STOMP is offered over WebSockets, the same service, on the same port
    (8675) provides bare STOMP also, for clients not requiring a WebSockets
    transport. The JRuby and Java clients can seamlessly communicate with the
    TorqueBox STOMP server using either TCP/IP, or WebSockets as the
    underlying transport.</para>
  </section>
</chapter>
